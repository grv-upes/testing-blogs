<div style="text-align: left;"><div class="separator" style="clear: both; text-align: center;"><a href="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpumpkinprogrammerdotcom4.files.wordpress.com%2F2014%2F06%2Flinked_list_0.jpg&amp;f=1&amp;nofb=1" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="539" data-original-width="732" height="338" src="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fpumpkinprogrammerdotcom4.files.wordpress.com%2F2014%2F06%2Flinked_list_0.jpg&amp;f=1&amp;nofb=1" width="494" /></a></div><h2 style="text-align: left;"><span style="font-family: georgia;">Problem Statement:-</span></h2><div><span style="font-family: georgia; font-size: medium;">Given a linked list of N nodes where nodes can contain values 0s, 1s, and 2s only. The task is to segregate 0s, 1s, and 2s linked list such that all zeros segregate to the head side, 2s at the end of the linked list, and 1s in the mid of 0s and 2s.</span></div><h3 style="text-align: left;"><span style="font-family: georgia;"><br />Example 1:</span></h3><div><pre style="background-color: whitesmoke; border-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; line-height: 1.42857; margin-bottom: 10px; margin-top: 0px; overflow-wrap: break-word; overflow: auto; padding: 9.5px; word-break: break-all;"><span style="box-sizing: border-box; font-family: georgia;"><span style="box-sizing: border-box;">I<b>nput:
</b></span>N = 8
value[] = {1,2,2,1,2,0,2,2}
<span style="box-sizing: border-box; font-weight: 700;">Output: </span>0 1 1 2 2 2 2 2<span style="box-sizing: border-box; font-weight: 700;">
Explanation: </span>All the 0s are segregated
to the left end of the linked list,
2s to the right end of the list, and
1s in between.</span></pre></div><div><span style="font-family: georgia;">Link to Problem:&nbsp;<a href="https://practice.geeksforgeeks.org/problems/given-a-linked-list-of-0s-1s-and-2s-sort-it/1" target="_blank">Sorting a Linked List of 0's, 1's and 2's</a></span></div><div><span style="font-family: georgia;"><br /></span></div><h2 style="text-align: left;"><span style="font-family: georgia;">Solution:-</span></h2><div><span style="font-family: georgia; font-size: medium;">The basic approach to solve this problem would be to store the count of&nbsp; 0's, 1's, and 2's and then changing the value of the nodes of the LinkedList.&nbsp;</span></div><div><span style="font-family: georgia; font-size: medium;"><br /></span></div><div><span style="font-family: georgia; font-size: medium;">And this is an optimal approach as well, many people will argue that since we are storing the count of&nbsp; 0's, 1's, and 2's, it will be using O(N) extra space. But no, we will be using O(1) space to store the count of elements, since, for each test case, we will only require to store the count of 3 numbers (0, 1, 2).&nbsp;</span></div><div><span style="font-family: georgia; font-size: medium;"><br /></span></div><div><span style="font-family: georgia; font-size: medium;">Let us now look at the solution:</span></div><div><span style="font-family: georgia;"><br /></span></div><div><span style="font-family: georgia;"><pre style="background-color: whitesmoke; border-radius: 4px; border: 1px solid rgb(204, 204, 204); box-sizing: border-box; color: #333333; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px; line-height: 1.42857; margin-bottom: 10px; margin-top: 0px; overflow-wrap: break-word; overflow: auto; padding: 9.5px; word-break: break-all;"><p style="color: black; font-family: &quot;Times New Roman&quot;; font-size: medium; white-space: normal;"><span style="font-family: georgia;">Node* segregate(Node *head) {<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; // first we will be checking if the linked list passed is<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; // valid or not<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; if(!head){<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; return head;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; }<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; Node *ptr = head;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp;&nbsp;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; // to store the count of 0, 1 and 2<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; int count[3] = {0, 0, 0};<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; while(ptr){<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; ++count[ptr-&gt;data];<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; ptr=ptr-&gt;next;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; }<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; ptr = head;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; int i = 0;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp;&nbsp;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; // updating the value of each node<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; while(ptr){<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; if(count[i]==0){<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++i;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; }else{<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr-&gt;data = i;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ptr = ptr-&gt;next;<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; --count[i];<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; &nbsp; &nbsp; }<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; }<br /></span><span style="font-family: georgia;">&nbsp; &nbsp; return head;<br /></span><span style="font-family: georgia;">}</span></p></pre></span></div><div><span style="font-family: georgia; font-size: medium;">Let us now analyze our solution:</span></div><div><span style="font-family: georgia; font-size: large;"><br /></span></div><div><span style="font-family: georgia; font-size: large;">The space complexity for this solution would be O(1) since we are not using any extra space for this. The space used will be constant.</span></div><div><span style="font-family: georgia; font-size: medium;"><br /></span></div><div><span style="font-family: georgia; font-size: medium;">The time complexity for this solution would be O(N), where N is the number of nodes in the linked list. We will be traversing the entire linked list to store the count of 0's, 1's, and 2's and then we will again traverse the entire linked list to update the value of each node in ascending order.&nbsp;</span></div><div><span style="font-family: georgia; font-size: medium;"><br /></span></div><div><span style="font-family: georgia; font-size: medium;">You may also refer to my Github Repo where I keep uploading solutions for multiple DSA problems daily.</span></div><div><span style="font-family: georgia; font-size: medium;"><br /></span></div><div><span style="font-family: georgia; font-size: medium;"><a href="https://github.com/cptn3m0grv/dsa-practice" target="_blank">DSA Practice Github Repo</a></span></div><div><br /></div></div>